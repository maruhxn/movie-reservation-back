# 영화 에매 서비스 (backend)

v1.0.0
2023-07-04

## STACK

- CLIENT: Next.js
- SERVER: Nest.js
- DB: PostgreSQL
- Cache: Redis
- cloud storage: amazon s3 or cloudinary
- Auth: Passport - Local, Kakao
- Deploy: Vercel(client) + AWS EC2 or AWS Lightsail or AWS Lambda(server) + AWS RDS + upstash +
- CI/CD: Github Actions + Docker

## 유저 기능

- 로그인 / 회원가입 기능 - Email 로그인, Kakao 로그인
- 유저는 현재 상영 중인 영화 정보를 확인할 수 있다.
- 유저는 로그인 후 '예매하기 -> 영화선택 -> 날짜 선택 -> (해당 영화 상영일에 존재하는 스케쥴을 보여줌) 시간 선택 -> 선택 + 좌석 선택 -> 결제하기'의 흐름을 따라 영화 예매가 가능하다.
- 영화스케쥴은 영화, 상영 시간, 상영관으로 이루어져 있다.
- 하나의 상영관에서 여러 스케쥴이 있을 수 있고 하나의 스케쥴은 하나의 상영관만을 가진다.
- 예약 생성 시 영화 스케쥴 정보와 예약한 유저 정보, 예약한 좌석 정보, 예약 인원 등이 필요하다.
- 쿠폰이 존재하고 기간이 유효하다면 쿠폰을 통해 할인을 받을 수 있다. (보류)
- 쿠폰을 어떻게 받을까? (일단은 특정 영화의 예매 건수가 10회가 넘어가면 메인 페이지에 쿠폰 10장을 뿌리는 방식을 구현해보자.) (보류)
- "매일 01시 00분"에 open API로부터 현재 상영 중인 영화 정보 및 세부 정보를 받아오고, 이를 DB에 저장 및 업데이트한다.

## 관리자 기능

- 앱이 처음 실행될 때, DB 초기화

- 관리자 계정을 통해 로그인 하여 관리자 페이지에 접근할 수 있다.
- 관리자는 상영 중인 영화를 원할 때마다 불러올 수 있다. (open api의 한계 limit도 고려할 필요) -> 불러온 데이터를 통해 DB에 저장 및 업데이트 하여 영화를 관리한다.
- 영화 스케쥴을 관리할 수 있다. (영화, 상영시간, 상영관을 선택하여 추가 + 수정 + 삭제)
- 상영관을 추가 및 삭제할 수 있다. -> 상영관마다 좌석 수를 다르게 배정할 필요
- 예매된 표를 정렬 기준에 따라 확인 및 관리할 수 있다.
- 관리자의 권한으로 예매표를 추가, 수정, 삭제할 경우 -> 예매한 유저의 이메일 혹은 전화번호를 통해 푸시알림이 간다.
- 쿠폰을 관리할 수 있다. (쿠폰 이름, 할인율, 할인 기간 등) (보류)

### 상영 종료 기준

- 개봉일로부터 한달이 지났으면 out-dated로 상영 종료.

예매 정보를 어떻게 받아올 것인가?

1. 유저를 조회 시 예매 정보를 같이 불러옴. -> 한번만 조회하면, 모든 정보를 불러올 수 있지만, 불필요한 정보도 들어오게 됨.
   => 예매 정보를 최소화시킨다면, 네트워크 요청 수를 줄이고 클라이언트 측 논리를 단순화 시킬 수 있음.
   => 단일 쿼리를 사용하기 때문에, 네트워크 대기 시간이 길거나 요청 수를 최소화해야 하는 시나리오에서 유리 (서버 왕복 오버헤드 줄임.)
2. 따로 reservation/:userId 엔드포인트를 두어서 userId에 해당하는 예매 정보를 모두 불러오게 함. => 이는 유저 아이디에 해당하는 예매 정보만 따로 필요한 경우가 있다면 유용. 그렇지 않다면 불필요..
   => 관심사 분리? 예약 정보가 개념적으로 사용자 엔터티와 분리되어 있고 고유한 작업 집합이 있는 경우 /reservation/:userId와 같은 별도의 엔드포인트를 갖는 것이 더 나을 수 있음.
   => 또한, 확장성이 생김. 예약 데이터의 크기가 커지거나 복잡해지면 전용 엔드포인트로 분리하면 사용자 정보와 독립적으로 더 쉽게 관리하고 확장할 수 있음. => 성능 최적화, 캐싱 및 예약 관련 작업 확장에 더 많은 유연성 제공.

우린 1번으로 하자! 사용자 엔터티와 관련성이 매우 크고, 사용자 정보와 독립적으로 사용할 일은 크게 없을 것 같다..

# TO DO LIST

- Unit Test [50%]
- E2E Test []
- redis 적용 (movie 정보? moveiSchedule 정보?를 받아두자.)
- Transaction 적용

## 고민사항..

- 기존 테이블 구조에서 seat와 reservation 테이블이 one to many로 연결되어 있었음.. 그래서 같은 영화 및 상영관이고 시간대만 다른 경우에도 상영관이 좌석을 공유하기에 seat에 reservationId가 있다면 이미 예매 완료 상태가 되어버림.. 어떻게 해결해야할까?
  => seat와 reservation 사이의 relation을 삭제. 이후 reservation에서 seat를 참조할 수 있게 seatIds라는 string 배열을 저장함. movieShcedule을 선택하여 상영관의 좌석을 보여줄 때, movieScedule.screen.seats를 모두 보여주고, movieScedule.reservations.seatIds를 순회하여 해당하는 것이 있다면 좌석을 선택할 수 없도록 만들자. (클라에서? 서버에서?) 남은 좌석을 보여주는 것은 movieSchedule.screen.seatAmt - movieSchedule.reservations.map(reservation => seatIds.length) 를 통해 계산하여 보여주면 될것.
  => 근데 이러면 movieSchedule을 선택할 때마다 너무 많은 연산이 필요하게 됨.. index, 캐싱, 클라에게 양도가 필요할듯.
